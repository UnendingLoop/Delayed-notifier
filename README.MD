# Delayed Notifier

## Описание проекта

**Delayed Notifier** - сервис для отложенной отправки уведомлений.

Ключевая идея проекта - реализовать:
- *плановую доставку сообщений*,
- *retry-механику*,
- 2 вида хранения данных(storage):
   - in-memory map(без сохранения данных между запусками приложения)
   - PostgresQL()
- без внешних таймеров (cron, background jobs),
- использовать функциональность фреймворка WBF.

Вся логика задержек, повторных попыток и маршрутизации сообщений построена на стандартных механизмах RabbitMQ:

* TTL (Time-To-Live)
* Dead Letter Exchange (DLX)
* Routing keys

---

## Архитектура

Поток обработки уведомления:

1. API принимает запрос на создание уведомления с `send_at`
2. Уведомление сохраняется в storage со статусом `queued`
3. ID уведомления публикуется в **очередь задержки** с TTL
4. После истечения TTL сообщение автоматически попадает в **рабочую очередь**
5. Worker читает сообщение и:

   * проверяет актуальный статус в storage
   * пытается отправить уведомление
   * при ошибке отправляет сообщение в retry-очередь
6. Retry-очередь использует экспоненциальную задержку
7. После превышения лимита попыток(5 раз) уведомление помечается как `dead`

RabbitMQ используется **только как транспорт и механизм таймингов**, вся бизнес-логика находится в слое **service** приложения.

---

## Топология RabbitMQ

В проекте используются **три очереди** и **один exchange**.

### Exchange

```
notifications_exchange (direct)
```

---

### Очередь 1 — Delay Queue

```
notifications_delay_queue
```

Назначение:

* принимает ID новых уведомлений
* содержит TTL = время до `send_at`
* после истечения TTL сообщение автоматически переходит в рабочую очередь **notifications_queue**

Настройки:

* x-dead-letter-exchange: notifications_exchange
* x-dead-letter-routing-key: send

---

### Очередь 2 — Worker Queue

```
notifications_queue
```

Назначение:

* основная очередь, из которой читает воркер приложения
* сообщения попадают в эту очередь после наступления времени отправки(после истечения TTL)
* при NACK сообщение переходит в **notifications_retry_queue**

Настройки:

* x-dead-letter-exchange: notifications_exchange
* x-dead-letter-routing-key: retry

---

### Очередь 3 — Retry Queue

```
notifications_retry_queue
```

Назначение:

* повторная обработка сообщений при ошибках отправки
* реализует экспоненциальную задержку

Механика:

* TTL задаётся **на уровне сообщения**
* после истечения TTL сообщение возвращается в worker-очередь

Заголовки сообщений:

* `x-retries` — количество попыток обработки

---

## Retry-механизм

Retry реализован без таймеров и фоновых задач:

* при ошибке воркер публикует сообщение в retry-очередь
* TTL рассчитывается по формуле экспоненциальной задержки
* количество попыток хранится в заголовке `x-retries`
* после достижения лимита уведомление помечается как `dead`


---

## Слои приложения

```
cmd/
 ├── app/           # Инициализация приложения
internal/
 ├── queue/         # RabbitMQ топология и публикация
 ├── worker/        # Консюмер и бизнес-логика обработки
 ├── service/       # Бизнес-логика уведомлений
 ├── repository/    # Хранилище (Postgres / in-memory)
 ├── sender/        # Абстракция отправки уведомлений(пока просто заглушка - всегда возвращает успешную отправку)
 ├── transport/     # HTTP API (Gin)
 ├── web/           # Примитивный UI: форма для создания уведомления и таблица для отображения всех уведомлений
 └── cache/         # Redis-кэш
 
```

---

## ⚙️ Конфигурация

Пример `.env`:

```
POSTGRES_DSN=postgres://user:pass@postgres:5432/db?sslmode=disable
RABBIT_ADDR=amqp://guest:guest@rabbit:5672/
RABBIT_NAME=delayed-notifier
REDIS_ADDR=redis:6379
REDIS_PASSWORD=
STORAGE_TYPE=in-memory
```

---

## Запуск проекта

### Для запуска storage в режиме **in-memory**:
```.env
...
STORAGE_TYPE=in-memory
...
```
```bash
docker compose up --build
```
### Для запуска storage в режиме **PostgresQL**
```.env
...
STORAGE_TYPE=postgres
...
```
```bash
docker compose --profile postgres up --build 
```

### После запуска:

* API доступен на `http://localhost:8080/api/notify`
* WEB-интерфейс доступен на `http://localhost:8080/web`
* RabbitMQ UI: `http://localhost:15672`

---

## API

### Создание уведомления

```
POST /api/notify
```

Тело запроса:

```json
{
  "user_id": "123",
  "message": "Hello",
  "send_at": "2025-12-14T12:00:00Z"
}
```

---

## Гарантии обработки

* уведомления не теряются при перезапуске сервиса(при сипользовании Postgres)
* отложенная доставка работает без cron
* сообщения не отправляются повторно при изменении статуса
* бизнес-логика всегда проверяет актуальное состояние в storage

---

## Цель проекта

* показать корректную работу с RabbitMQ
* реализовать delay и retry **без плагинов**
* продемонстрировать чистую архитектуру

